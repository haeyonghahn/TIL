# Kafka
## Kafka란?
- 실시간 데이터 피드를 관리하기 위해 통일된 높은 처리량, 낮은 지연 시간을 지닌 플랫폼이다.
- 모든 시스템으로 데이터를 실시간으로 전송하여 처리할 수 있는 시스템이다.
- 데이터가 많아지더라도 확장이 용이한 시스템이다.

중간에 `kafka`를 도입하게되면서 mySQL, Oracle, mongoDB, 어플리케이션, 데이터 스토리지 등 자신들이 전송하는 데이터가 어떠한 시스템에 저장되는지에 관계없이 하둡이라든지, 모니터링 시스템 등에 전달해줄 때  `kafka` 쌓여 있는 메시지들이 단일 포맷으로 전달될 수 있도록 한다. 어떤 곳에서 보내든, 누가 받든 신경쓰지 않고 메시지를 주고 받는 것이 가능해진다.

- Producer/Consumer 분리
- 메시지를 여러 Consumer에게 허용
- 높은 처리량을 위한 메시지 최적화
- scale-out 가능

![image](https://user-images.githubusercontent.com/31242766/197794620-f1c47792-62c9-4a0c-9557-2a20738ce481.png) 

## Kafka Broker
- 실행된 Kafka 애플리케이션 서버
- 3대 이상의 Broker Cluster 구성
- Zookeeper 연동
  - 메타데이터(Broker ID, Controller ID 등) 저장 
  - Controller 정보 저장
- n개 Broker 중 1대는 Controller 기능 수행
  - Controller 역할
    - 각 Broker에게 담당 파티션 할당 수행
    - Broker 정상 동작 모니터링 관리

![image](https://user-images.githubusercontent.com/31242766/197796709-4d662617-feb2-4271-baef-43e1b27eb776.png)

- `KafkaCluster` : 카프카의 브로커들의 모임이다. Kafka는 확장성과 고가용성을 위하여 broker들이 클러스터로 구성되어 있다.
- `Broker` : 각각의 카프카 서버이다. 동일 노드에 여러 브로커를 띄울 수 있다.
- `Zookeeper` : 카프카 클러스터 정보 및 분산처리 관리 등 메타데이터를 저장한다.
- `Producer` : 메시지(이벤트)를 발행하여 생산(Write)하는 주체
- `Consumer` : 메시지(이벤트)를 구독하여 소비(Read)하는 주체

## 토픽, 파티션, 오프셋
![image](https://user-images.githubusercontent.com/31242766/197800445-cdb27648-ae35-405f-b4e8-e10423c3c0fa.png)

- 카프카에 저장되는 메시지는 topic으로 분류, topic은 여러개의 patition으로 나눠진다.
- `Topic` : 메시지를 구분하는 단위이다.
  - 파일시스템의 폴더, 메일함과 유사하다. ex) 주문용 토픽, 결제용 토픽 등
- `Partition` : 메세지를 저장하는 물리적인 파일이다.
  - 한 개의 토픽은 한 개 이상의 파티션으로 구성된다. 
  - 파티션은 메시지 추가만 가능한 파일(append-only)이다.
- `offset` : 파티션내 각 메시지의 저장된 상대적 위치이다.
- 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가된다.(Queue)
- 컨슈머는 오프셋 기준으로 마지막 커밋 시점부터 메시지를 순서대로 읽어서 처리한다.
- 파티션의 메시지 파일은 처리 후에도 계속 저장되어 있며 설정에 따라 일정시간 뒤 삭제된다.

## 프로듀서
![image](https://user-images.githubusercontent.com/31242766/197801230-bc6d3f8b-b064-4b7a-9fcd-8bae7ad72bc2.png)

- `Producer` : 메시지(이벤트)를 발행하여 생산(Wirte) 하는 주체이다.
- 프로듀서는 메시지 전송시 토픽을 지정한다.
- 파티션은 라운드로빈 방식 혹은 파티션 번호를 지정하여 넣을 수 있다.
- 같은 키를 갖는 메시지는 같은 파티션에 저장 되며 순서를 유지한다.

## 컨슈머
![image](https://user-images.githubusercontent.com/31242766/197801695-938cc61d-4a51-48e8-a8b8-de4abcd8a6f9.png)

- `Consumer` : 메시지(이벤트)를 구독하며 소비(Read)하는 주체
- Consumer Group
  - 메시지를 소비하는 컨슈머들의 논리적 그룹이다.
  - Topic의 파티션은 컨슈머 그룹과 1:N 매칭 관계로 동일 그룹내 한 개의 컨슈머만 연결가능 하다.
  - 이로써 파티션의 메시지는 순서대로 처리되도록 보장한다.
  - 특정 컨슈머에 문제가 생겼을때 Fail over를 통한 리밸런싱 가능하다.
  - 보통 파티션과 컨슈머는 1:1이 best practice로 본다.

## Kafka 사용 이유
### 고성능
- 다중 프로듀서, 다중 컨슈머가 상호 간섭없이 메시지를 쓰고 읽어서 처리한다.
- 디스크 기반의 이벤트 보존
  - 지속해서 보존이 가능하고 데이터 유실 위헙이 적으며 컨슈머가 항상 안떠있어도 된다.
  - 장애 발생시 유실 복구 가능(재처리)하다.
  - 파티션 파일은 OS 페이지 캐시를 통해 IO를 메모리에서 처리하여 성능이 유리하다.
- 브로커가 하는 일이 비교적 단순하다.
  - 브로커는 컨슈머와 파티션 간 맵핑 관리만 하여 성능에 집중한다.
  - 메시지 필터, 메시지 재전송과 같은 일은 프로듀서, 컨슈머에 위임한다.
- batch 기능을 제공하여 동시 처리량이 증가한다.
  - 프로듀서 : 일정 크기만큼 메시지를 모아서 전송한다.
  - 컨슈머 : 최소 크기만큼 메시지를 모아서 읽어온다.
- 확장성(scale out) : 수평 확장이 쉽게 가능하다 -> 브로커, 파티션, 컨슈머 추가

### 고가용성(HA - High Availability)
- Kafka의 `topic`은 `partition`이라는 단위로 쪼개어져 클러스터의 각 서버들에 분산되어 저장되고, 고가용성을 위하여 복제(replication) 설정을 할 경우 이 또한 `partition` 단위로 각 서버들에 분산되어 복제되고 장애가 발생하면 `partition` 단위로 fail over가 수행된다.
- `Replication` : 토픽내 파티션의 복제본이다. replication-factor 를 통해 개수를 지정할 수 있다.
  - 복제수(replication-factor) 만큼 파티션의 복제본이 각 브로커에 생긴다.
  - 토픽 생성시 복제수를 2로 하면 파티션이 2개가 각각의 브로커에 생긴다.
- `leader`와 `follower`로 구성
  - 프로듀서, 컨슈머는 리더를 통해서만 메시지 처리한다.
  - 팔로워는 리더가 속한 브로커에서 메시지를 복제한다.
- 리더가 속한 브로커가 장애나면 다른 팔로워가 리더가 되서 처리한다.

## 참고
https://ifuwanna.tistory.com/487    
