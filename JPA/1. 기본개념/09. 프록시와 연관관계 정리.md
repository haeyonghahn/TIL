# 프록시와 연관관계 정리
## 프록시
엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. 예를 들어 회원 엔티티를 조회할 때 연관된 팀 엔티티는 비즈니스 로직에 따라 사용될 때도 있지만 그렇지 않을 때도 있다.   

====== 회원과 팀 정보를 출력하는 비즈니스 로직 ======     
```java
public void printUserAndTeam(String memberId) {
 Member member = em.find(Member.class, memberId);
 Team team = member.getTeam();
 System.out.println("회원 이름 : " + member.getUsername());
 System.out.println("소속팀 : " + team.getName()); //**
}
```
====== 회원 정보만 출력하는 비즈니스 로직 ======     
```java
public String printUser(String memberId) {
 Member member = em.find(Member.class, memberId);
 System.out.println("회원 이름 : " + member.getUsername());
}
```
`printUserAndTeam()` 메서드는 `memberId` 로 회원 엔티티를 찾아서 회원은 물론이고 회원과 연관된 팀의 이름도 출력한다. 반면에 `printUser()` 메서드는 회원 엔티티만 출력하는데 사용하고 회원과 연관된 팀 엔티티는 전혀 사용하지 않는다.    

`printUser()` 메서드는 회원 엔티티만 사용하므로 `em.find()` 로 회원 엔티티를 조회할 때 회원과 연관된 팀 엔티티( `Member.team` )까지 데이터베이스에서 함께 조회해 두는 것은 효율적이지 않다.

JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 지연 로딩이라 한다. 쉽게 이야기해서 `team.getName()` 처럼 팀 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 팀 엔티티에 필요한 데이터를 조회하는 것이다. 이 방법을 사용하면 `printUser()` 메서드는 회원 데이터만 데이터베이스에서 조회해도 된다.   

그런데 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.

### 프록시 기초
JPA에서 식별자로 엔티티 하나를 조회할 때는 `EntityManager.find()` 를 사용한다. 이 메서드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.
```java
Member member = em.find(Member.class, "member1");
```
이렇게 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다. 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 `EntityManager.getReference()` 메서드를 사용하면 된다.
```java
Member member = em.getReference(Member.class, "member1");
```
이 메서드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다. 대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다.
#### 프록시의 특징
- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다. 따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체에 대한 참조( `target` )를 보관한다. 그리고 프록시 객체의 메서드를 호출하면 프록시 객체는 실제 객체의 메서드를 호출한다.

#### 프록시 객체의 초기화
프록시 객체는 `member.getName()` 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.
1. 프록시 객체에 `member.getName()`을 호출해서 실제 데이터를 조회한다.
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 `초기화`라 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 엔티티 객체의 참조를 `Member target` 멤버변수에 보관한다.
5. 프록시 객체는 실제 엔티티 객체의 `getName()`을 호출해서 결과를 반환한다.

#### 프록시의 특징
- 프록시 객체는 처음 사용할 때 한 번만 초기화 된다.
- 프록시 객체를 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 `em.getReference()` 를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 하이버네이트는 `org.hibernate.LazyInitializationException` 예외를 발생시킨다.

#### 준영속 상태와 초기화
```java
Member member = em.getReference(Member.class, "id1"); //MemberProxy 반환
transaction.commit();
em.close(); //영속성 컨텍스트 종료
member.getName(); //준영속 상태 초기화 시도, org.hibernate.LazyInitializationException
```
영속성 컨텍스트를 종료해서 `member` 는 준영속 상태다. `member.getName()` 을 호출하면 프록시를 초기화해야 하는데 영속성 컨텍스트가 없으므로 실제 엔티티를 조회할 수 없다. 따라서 예외가 발생한다.

### 프록시와 식별자
엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.
```java
Team team = em.getReference(Team.class, "team1"); //식별자 보관
team.getId(); //초기화되지 않음
```
프록시 객체는 식별자 값을 가지고 있으므로 식별자 값을 조회하는 `team.getId()` 를 호출해도 프록시를 초기화하지 않는다. 단 엔티티 접근 방식을 프로퍼티( `@Access(AccessType.PROPERTY)` )로 설정한 경우에만 초기화하지 않는다.
엔티티 접근 방식을 필드( `@Access(AccessType.FIELD)` )로 설정하면 JPA는 `getId()` 메서드가 `id` 만 조회하는 메서드인지 다른 필드까지 활용해서 어떤 일을 하는 메서드인지 알지 못하므로 프록시 객체를 초기화한다.
#### 프록시를 활용한 연관관계 설정
```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1"); //SQL을 실행하지 않음
member.setTeam(team);
```
연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다. 참고로 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화 하지 않는다.
### 프록시 확인하기
JPA가 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메서드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다. 아직 초기화 되지 않은 프록시 인스턴스는 `false` 를 반환한다. 이미 초기화 되었거나 프록시 인스턴스가 아니면 `true` 를 반환한다.
```java
boolean isLoad = em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(entity);
//또는 boolean isLoad = emf.getPersistenceUnitUtil().isLoaded(entity);
System.out.println("isLoad = " + isLoad); //초기화 여부 확인
```
조회한 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면 클래스 명을 직접 출력해보면 된다. 다음 예를 보면 클래스 명 뒤에 `..javassist..` 라 되어 있는데 이것으로 프록시인 것을 확인할 수 있다. 프록시를 생성하는 라이브러리에 따라 출력 결과는 달라질 수 있다.
```java
System.out.println("memberProxy = " + member.getClass().getName());
//결과 : memberProxy = jpabook.domain.Member_$$_javassist_0
```
#### 프록시 강제 초기화
하이버네이트의 `initialize()` 메서드를 사용하면 프록시를 강제로 초기화할 수 있다.
```java
org.hibernate.Hibernate.initialize(order.getMember()); //프록시 초기화
```
JPA 표준에는 프록시 강제 초기화 메서드가 없다. 따라서 강제로 초기화 하려면 `member.getName()` 처럼 프록시의 메서드를 직접 호출하면 된다. JPA 표준은 단지 초기화 여부만 확인할 수 있다.

## 즉시 로딩과 지연 로딩
프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.
```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); //객체 그래프 탐색
System.out.println(team.getName()); //팀 엔티티 사용
```
회원 엔티티를 조회할 때 연관된 팀 엔티티도 함께 데이터베이스에서 조회하는 것이 좋을까? 아니면 회원 엔티티만 조회해 두고 팀 엔티티는 실제 사용하는 시점에 데이터베이스에서 조회하는 것이 좋을까?
- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. 
  - 예) : `em.find(Member.class, "member1")` 를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회한다.
  - 설정 방법 : `@ManyToOne(fetch = FetchType.EAGER)`
- 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다. 
  - 예): `member.getTeam().getName()` 처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회한다.
  - 설정 방법: `@ManyToOne(fetch = FetchType.LAZY)`

### 즉시 로딩(EAGER LOADING)
즉시 로딩을 사용하려면 `@ManyToOne` 의` fetch` 속성을 `FetchType.EAGER` 로 지정한다.
```java
@Entity
public class Member {
 //...
 @ManyToOne(fetch = FetchType.EAGER) //**
 @JoinColumn(name = "TEAM_ID")
 private Team team;
 //...
}

Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); //객체 그래프 탐색
```
회원과 팀을 즉시 로딩으로 설정했다. 따라서 em.find(Member.class, "member1") 로 회원을 조회하는 순간 팀도 함께 조회한다. 이때 회원과 팀 두 테이블을 조회해야 하므로 쿼리를 2번 실행할 것 같지만, 대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다. 여기서는 회원과 팀을 조인해서 쿼리 한 번으로 두 엔티티를 모두 조회한다.      

====== 즉시 로딩 실행 SQL ======
```sql
SELECT
 M.MEMBER_ID AS MEMBER_ID,
 M.TEAM_ID AS TEAM_ID,
 M.USERNAME AS USERNAME,
 T.TEAM_ID AS TEAM_ID,
 T.NAME AS NAME 
FROM
 MEMBER M LEFT OUTER JOIN TEAM T 
 ON M.TEAM_ID=T.TEAM_ID 
WHERE
 M.MEMBER_ID='member1'
```
이후 `member.getTeam()` 를 호출하면 이미 로딩된 팀1 엔티티를 반환한다.

#### 널 제약조건과 JPA 조인 전략
즉시 로딩 실행 SQL에서 JPA가 내부 조인(INNER JOIN)이 아닌 외부 조인 (LEFT OUTER JOIN)을 사용한 것을 유심히 봐야 한다. 현재 회원 테이블에 `TEAM_ID` 외래 키는 널( `null` ) 값을 허용하고 있다. 따라서 팀에 소속되지 않은 회원이 있을 가능성이 있다. 팀에 소속하지 않은 회원과 팀을 내부 조인하면 팀은 물론이고 회원 데이터도 조회할 수 없다.
JPA는 이런 상황을 고려해서 외부 조인을 사용한다. 하지만 외부 조인보다 내부 조인이 성능과 최적화에서 더 유리하다. 그럼 내부 조인을 사용하려면 어떻게 해야 할까? 외래 키에 `NOT NULL` 제약 조건을 설정하면 값이 있는 것을 보장한다. 따라서 이때는 내부 조인만 사용해도 된다. JPA에게도 이런 사실을 알려줘야 한다. 다음 코드처럼 `@JoinColumn` 에 `nullable = false` 을 설정해서 이 외래 키는 널 값을 허용하지 않는다고 알려주면 JPA는 외부 조인 대신에 내부 조인을 사용한다.
```java
@Entity 
public class Member { 
 //... 
 @ManyToOne(fetch = FetchType.EAGER) 
 @JoinColumn(name = "TEAM_ID", nullable = false) //** 
 private Team team; 
 //... 
}
```
#### nullable 설정에 따른 조인 전략
- `@JoinColumn(nullable = true)` : 널 허용(기본값), 외부 조인 사용
- `@JoinColumn(nullable = false)` : 널 허용하지 않음, 내부 조인 사용

또는 다음처럼 `@ManyToOne.optional = false` 로 설정해도 내부 조인을 사용한다.
```java
@Entity 
public class Member { 
 //... 
 @ManyToOne(fetch = FetchType.EAGER, optional = false) //** 
 @JoinColumn(name = "TEAM_ID") 
 private Team team; 
 //... 
}
```
정리하자면 JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

### 지연 로딩(LAZY LOADING)
지연 로딩을 사용하려면 `@ManyToOne` 의 `fetch` 속성을 `FetchType.LAZY` 로 지정한다.
```java
@Entity
public class Member {
 //...
 @ManyToOne(fetch = FetchType.LAZY) //**
 @JoinColumn(name = "TEAM_ID")
 private Team team;
 //...
}

Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); //객체 그래프 탐색
team.getName(); //팀 객체 실제 사용
```
회원과 팀을 지연 로딩으로 설정했다. 따라서 `em.find(Member.class, "member1")` 를 호출하면 회원만 조회하고 팀은 조회하지 않는다. 대신에 조회한 회원의 `team` 멤버변수에 프록시 객체를 넣어둔다.
```java
Team team = member.getTeam(); //프록시 객체
```
반환된 팀 객체는 프록시 객체다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 그래서 지연 로딩이라 한다.
```java
team.getName(); //팀 객체 실제 사용
```
이처럼 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화 한다.

====== `em.find(Member.class, "member1")` 호출시 ======    
```sql
SELECT * FROM MEMBER
WHERE MEMBER_ID = 'member1'
```
====== `team.getName()` 호출시 프록시 객체 초기화 ======    
```sql
SELECT * FROM TEAM
WHERE TEAM_ID = 'team1'
```
조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다. 예를 들어 `team1` 엔티티가 영속성 컨텍스트에 이미 로딩되어 있으면 프록시가 이닌 실제 `team1` 엔티티를 사용한다.

#### 지연 로딩, 즉시 로딩 정리
처음부터 연관된 엔티티를 모두 영속성 컨텍스트에 올려두는 것은 현실적이지 않고, 필요할 때마다 SQL을 실행해서 연관된 엔티티를 지연 로딩하는 것도 최적화 관점에서 보면 꼭 좋은 것만은 아니다. 예를 들어 대부분의 애플리케이션 로직에서 회원과 팀 엔티티를 같이 사용한다면 SQL 조인을 사용해서 회원과 팀 엔티티를 한 번에 조회하는 것이 더 효율적이다.
결국 연관된 엔티티를 즉시 로딩하는 것이 좋은지 아니면 실제 사용할 때까지 지연해서 로딩하는 것이 좋은지는 상황에 따라 다르다.
- `지연 로딩 (LAZY)` : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- `즉시 로딩 (EAGER)` : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.
