# 연관관계 매핑
비즈니스 엔티티들은 대부분 다른 엔티티와 연관관계가 있다. 예를 들어 주문 엔티티는 어떤 상품을 주문했는지 알기 위해 상품 엔티티와 연관관계가 있고 상품 엔티티는 카테고리, 재고 등 또 다른 엔티티와 관계가 있다. 그런데 객체는 참조(주소)를 사용해서 관계를 맺고 테이블은 외래 키를 사용해서 관계를 맺는다. 이 둘은 완전히 다른 특징을 가진다. 객체 관계 매핑(ORM)에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.

#### 객체의 참조와 테이블의 외래 키를 매핑하는 것이 핵심이다.

- __방향(Direction)__ : [단방향, 양방향]이 있다. 예를 들어, 회원과 팀이 관계가 있을 때 `회원 -> 팀` 또는 `팀 -> 회원` 둘 중 한쪽만 참조하는 것을 단방향 관계라 하고, `회원 -> 팀`, `팀 -> 회원` 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.
- __다중성(Multiplicity)__ : [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)] 다중성이 있다. 예를 들어 회원과 팀이 관계가 있을 때 여러 회원은 한 팀에 속하므로 회원과 팀은 다대일 관계다. 반대로 한 팀에 여러 회원이 소속될 수 있으므로 팀과 회원은 일대다 관계다.
- __연관관계의 주인(owner)__ : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.

# 단방향 연관관계
![다대일관계](https://github.com/haeyonghahn/TIL/blob/master/JPA/images/%EB%8B%A4%EB%8C%80%EC%9D%BC%EA%B4%80%EA%B3%84.PNG)

### 객체 연관관계
- 회원 객체는 `Member.team`필드(멤버변수)로 팀 객체와 연관관계를 맺는다.
- 회원 객체와 팀 객체는 `단방향 관계`다. 회원은 `Member.team`필드를 통해서 팀을 알 수 있지만 반대로 팀은 회원을 알 수 없다. 예를 들어 `member -> team`의 조회는 `member.getTeam()`으로 가능하지만, 반대 방향인 `team -> member`를 접근하는 필드는 없다.

### 테이블 연관관계
- 회원 테이블은 `TEAM_ID` 외래 키로 팀 테이블과 연관관계를 맺는다.
- 회원 테이블과 팀 테이블은 `양방향 관계`다. 회원 테이블의 `TEAM_ID` 외래 키를 통해서 회원과 팀을 조인할 수 있고 반대로 팀과 회원도 조인할 수 있다. 예를 들어 `MEMBER`테이블의 `TEAM_ID` 외래 키 하나로 `MEMBER JOIN TEAM`과 `TEAM JOIN MEMBER`가 모두 가능하다.

#### 객체 연관관계와 테이블 연관관계의 가장 큰 차이
참조를 통한 연관관계는 언제나 단뱡향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다. 결국 연관관계를 하나 더 만들어야 한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. 하지만 정확히 이야기하면 `양방향 관계가 아니라 서로 다른 단방향 관계 2개다.` 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.    
====== 단방향 연관관계 ======
```java
class A {
 B b; 
}
class B {}
```
====== 양방향 연관관계 ======
```java
class A {
 B b; 
}
class B {
 A a;
}
```
- 연관된 데이터를 조회할 때 객체는 참조(`a.getB().getC()`)를 사용하지만, 테이블은 조인(JOIN)을 사용한다.
- 참조를 사용하는 객체의 연관관계는 단방향이다. (A -> B (a.b))
- 외래 키를 사용하는 테이블의 연관관계는 양방향이다. (A JOIN B 가 가능하면 반대로 B JOIN A 도 가능하다.)
- 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다. (A -> B (a.b), B -> A (b.a))

## 순수한 객체 연관관계
====== 회원 클래스 ======
```java
public class Member {
 private String id;
 private String username;
 private Team team; //팀의 참조를 보관
 public void setTeam(Team team) {
 this.team = team;
 }
 //Getter, Setter ...
}
```
====== 팀 클래스 ======
```java
public class Team {
 private String id;
 private String name;
 //Getter, Setter ...
}
```
회원1과 회원2를 팀1에 소속시키자.
```java
public static void main(String[] args) {
 //생성자(id, 이름)
 Member member1 = new Member("member1","회원1");
 Member member2 = new Member("member2","회원2");
 Team team1 = new Team("team1","팀1");
 member1.setTeam(team1);
 member2.setTeam(team1);
 Team findTeam = member1.getTeam(); 
}
```
회원1과 회원2는 팀1에 소속했다. 그리고 다음 코드로 회원1이 속한 팀1을 조회했다.
```java
Team findTeam = member1.getTeam();
```
이처럼 객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 `객체 그래프 탐색`이라 한다.

## 객체 관계 매핑하기
====== 매핑한 회원 엔티티 ======
```java
@Entity
public class Member {
 @Id
 @Column(name = "MEMBER_ID")
 private String id;
 private String username;
 //연관관계 매핑
 @ManyToOne //**
 @JoinColumn(name="TEAM_ID") //**
 private Team team;
 //연관관계 설정
 public void setTeam(Team team) {
 this.team = team;
 }
 //Getter, Setter ...
}
```
====== 매핑한 팀 엔티티 ======
```java
@Entity
public class Team {
 @Id
 @Column(name = "TEAM_ID")
 private String id;
 private String name;
 //Getter, Setter ...
}
```
- 객체 연관관계 : 회원 객체의 `Member.team` 필드를 사용
- 테이블 연관관계 : 회원 테이블의 `Member.TEAM_ID` 외래 키 컬럼을 사용

`Member.team`과 `MEMBER.TEAM_ID`를 매핑하는 것이 연관관계 매핑이다.
```java
@ManyToOne
@JoinColumn(name="TEAM_ID")
private Team team;
```
- @ManyToOne : 이름 그대로 다대일(N:1) 관계라는 매핑정보이다. 회원과 팀은 다대일 관계다. 연관관계를 매핑할 때 이렇게 다중성을 나타내는 어노테이션은 필수로 사용해야 한다.
- @JoinColumn(name="TEAM_ID") : 조인 컬럼은 외래 키를 매핑할 때 사용한다. `name`속성에는 매핑할 외래 키 이름을 지정한다. 회원과 팀 테이블은 `TEAM_ID`외래 키로 연관관계를 맺으므로 이 값을 지정하면 된다.

## @JoinColumn
외래 키를 매핑할 때 사용한다.
- name : 매핑할 외래 키 이름 `기본값 : 필드명 + _ + 참조하는 테이블의 기본 키 컬럼명`
- referencedColumnName : 외래 키가 참조하는 대상 테이블의 컬럼 `기본값 : 참조하는 테이블의 기본 키 컬럼을 이름으로 사용`
- foreignKey(DDL) : 외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.
- unique, nullable, insertable, updatable, columnDefinition, table : `@Column`의 속성과 같다.

#### @JoinColumn 생략
```java
@ManyToOne 
private Team team;
```
이처럼 `@JoinColumn` 을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다.
- 기본 전략 : 필드명 + _ + 참조하는 테이블의 기본 키 컬럼명
- 예) 필드명(team) + _ (언더라인) + 참조하는 기본 키 컬럼명(TEAM_ID) = team_TEAM_ID 외래 키를 사용한다.

## @ManyToOne
이 어노테이션은 다대일 관계에서 사용한다.
- optional : `false`로 설정하면 연관된 엔티티가 항상 있어야 한다. `기본값 : true`
- fetch : 글로벌 패치 전략을 설정한다. `기본값 : @ManyToOne=FetchType.EAGER, @OneToMany=FetchType.LAZY`
- cascade : 영속성 전이 기능을 사용한다.
- targetEntity : 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.

====== targetEntity 속성 사용 예 ======
```java
@OneToMany
private List<Member> members; //제네릭으로 타입 정보를 알 수 있다.
@OneToMany(targetEntity=Member.class)
private List members; //제네릭이 없으면 타입 정보를 알 수 없다.
```
## 연관관계 사용하기
### 저장
===== 회원과 팀을 저장하는 코드 =====
```java
public void testSave() {
 //팀1 저장
 Team team1 = new Team("team1", "팀1");
 em.persist(team1);
 //회원1 저장
 Member member1 = new Member("member1", "회원1");
 member1.setTeam(team1); //연관관계 설정 member1 -> team1
 em.persist(member1);
 //회원2 저장
 Member member2 = new Member("member2","회원2");
 member2.setTeam(team1); //연관관계 설정 member2 -> team1
 em.persist(member2);
}
```
JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

회원 엔티티는 팀 엔티티를 참조하고 저장했다. JPA는 참조한 팀의 식별자( Team.id )를 외래 키로 사용해서 적절한 등록 쿼리를 생성한다. 다음 실행된 SQL을 보면 회원 테이블의 외래 키 값으로 참조한 팀의 식별자 값인 team1 이 입력된 것을 확인할 수 있다.

====== 실행된 SQL ======
```sql
INSERT INTO TEAM (TEAM_ID, NAME) VALUES ('team1', '팀1')
INSERT INTO MEMBER (MEMBER_ID, NAME, TEAM_ID) VALUES ('member1', '회원1', 'team1')
INSERT INTO MEMBER (MEMBER_ID, NAME, TEAM_ID) VALUES ('member2', '회원2', 'team1')
```
### 조회
연관관계가 있는 엔티티를 조회하는 방법은 2가지가 있다.
- 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
- 객체 지향 쿼리 사용 (JPQL)

#### 객체 그래프 탐색
```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); //객체 그래프 탐색
System.out.println("팀 이름 = " + team.getName());
//출력결과: 팀 이름 = 팀1
```
#### 객체 지향 쿼리 사용
```java
private static void queryLogicJoin(EntityManager em) {
 String jpql = "select m from Member m join m.team t where t.name=:teamName";
 List<Member> resultList = em.createQuery(jpql, Member.class)
 .setParameter("teamName", "팀1");
 .getResultList();
 for (Member member : resultList) {
 System.out.println("[query] member.username=" + member.getUsername());
 }
}
//결과 : [query] member.username=회원1
//결과 : [query] member.username=회원2
```
### 수정
```java
private static void updateRelation(EntityManager em) {
 // 새로운 팀2
 Team team2 = new Team("team2","팀2");
 em.persist(team2);
 // 회원1에 새로운 팀2 설정
 Member member = em.find(Member.class, "member1");
 member.setTeam(team2);
}
```
영속성 관리에서 이야기했듯이 수정은 em.update() 같은 메서드가 없다. 단순히 불러온 엔티티의 값만 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. 그리고 변경사항을 데이터베이스에 자동으로 반영한다. 이것은 연관관계를 수정할 때도 같은데, 참조하는 대상만 변경하면 나머지는 JPA가 자동으로 처리한다.

### 연관관계 제거
회원1을 팀에 소속하지 않도록 변경하자.
===== 연관관계를 삭제하는 코드 =====
```java
private static void deleteRelation(EntityManager em) {
 Member member1 = em.find(Member.class, "member1");
 member1.setTeam(null); //연관관계 제거
}
```
===== 실행되는 연관관계 제거 SQL =====
```sql
UPDATE MEMBER 
SET
 TEAM_ID=null, ...
WHERE
 ID='member1'
```

### 연관된 엔티티 삭제
연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생한다.
```java
member1.setTeam(null); //회원1 연관관계 제거 
member2.setTeam(null); //회원2 연관관계 제거 
em.remove(team); //팀 삭제
```
#### 단방향 연관관계 정리
회원에서 팀으로 접근하는 예제로 다대일 단방향 매핑을 알아보았다. 이제부터 반대로 팀에서 회원으로 접근하는 일대다 연관관계를 매핑해보자. 그리고 회원에서 팀으로 접근하고 팀에서도 회원으로 접근할 수 있도록 양방향 관계로 매핑해보자.

## 양방향 연관관계
