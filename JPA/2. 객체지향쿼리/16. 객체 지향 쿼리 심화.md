# 객체 지향 쿼리 심화
## 벌크 연산
엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나 병합을 사용하고, 삭제하려면 `EntityManager.remove()` 메서드를 사용한다. 하지만 이 방법으로 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다. 이럴 때 여러 건을 한 번에 수정하거나 삭제하는 벌크 연산을 사용하면 된다.    

### 벌크 연산 수정
예를 들어 재고가 10개 미만인 모든 상품의 가격을 10% 상승시키려면 다음처럼 벌크연산을 사용하면 된다.
```java
String qlString = 
 "update Product p " +
 "set p.price = p.price * 1.1 " +
 "where p.stockAmount < :stockAmount";
 
int resultCount = em.createQuery(qlString)
 .setParameter("stockAmount", 10)
 .executeUpdate(); //**
```
연산은 `executeUpdate()` 메서드를 사용한다. 이 메서드는 벌크 연산으로 영향을 받은 엔티티 건수를 반환한다.

### 벌크 연산 삭제
삭제도 같은 메서드를 사용한다. 다음은 가격이 100원 미만인 상품을 삭제하는 코드다.
```java
String qlString =
 "delete from Product p " +
 "where p.price < :price";
int resultCount = em.createQuery(qlString)
 .setParameter("price", 100)
 .executeUpdate();
```

### 벌크 연산 추가
JPA 표준은 아니지만 하이버네이트는 INSERT 벌크 연산도 지원한다. 다음 코드는 100원 미만의 모든 상품을 선택해서 ProductTemp 에 저장한다.
```java
String qlString = 
 "insert into ProductTemp(id, name, price, stockAmount) " + 
 "select p.id, p.name, p.price, p.stockAmount from Product p " + 
 "where p.price < :price"; 
int resultCount = em.createQuery(qlString) 
 .setParameter("price", 100) 
 .executeUpdate();
```
### 벌크 연산의 주의점
벌크 연산을 사용할 때는 `벌크 연산이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리`한다는 점에 주의해야 한다. 이런 문제를 해결하는 다양한 방법을 알아보자.
#### em.refresh() 사용
벌크 연산을 수행한 직후에 정확한 상품A 엔티티를 사용해야 한다면 `em.refresh()` 를 사용해서 데이터베이스에서 상품A를 다시 조회하면 된다.
```java
em.refresh(productA); // 데이터베이스에서 상품A를 다시 조회한다.
```
#### 벌크 연산 먼저 실행
가장 실용적인 해결책은 벌크 연산을 가장 먼저 실행하는 것이다. 예를 들어 위에서 벌크 연산을 먼저 실행하고 나서 상품A를 조회하면 벌크 연산으로 이미 변경된 상품A를 조회하게 된다. 이 방법은 JPA와 JDBC를 함께 사용할 때도 유용하다.

#### 벌크 연산 수행 후 영속성 컨텍스트 초기화
벌크 연산을 수행한 직후에 바로 영속성 컨텍스트를 초기화해서 영속성 컨텍스트에 남아있는 엔티티를 제거하는 것도 좋은 방법이다. 그렇지 않으면 엔티티를 조회할 때 영속성 컨텍스트에 남아 있는 엔티티를 조회할 수 있는데 이 엔티티에는 벌크 연산이 적용되어 있지 않다. 영속성 컨텍스트를 초기화하면 이후 엔티티를 조회할 때 벌크 연산이 적용된 데이터베이스에서 엔티티를 조회한다.

#### 벌크 연산 정리
벌크 연산은 영속성 컨텍스트와 2차 캐시를 무시하고 데이터베이스에 직접 실행한다. 따라서 영속성 컨텍스트와 데이터베이스 간에 데이터 차이가 발생할 수 있으므로 주의해서 사용해야 한다. 가능하면 벌크 연산을 가장 먼저 수행하는 것이 좋고 상황에 따라 영속성 컨텍스트를 초기화하는 것도 필요하다.

## JPQL로 조회한 엔티티와 영속성 컨텍스트
JPQL로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 JPQL로 조회한 결과를 버리고 대신에 영속성 컨텍스트에 있던 엔티티를 반환한다. 이때 식별자 값을 사용해서 비교한다.
1. JPQL을 사용해서 조회를 요청한다.
2. JPQL은 SQL로 변환되어 데이터베이스를 조회한다.
3. 조회한 결과와 영속성 컨텍스트를 비교한다.
4. 식별자 값을 기준으로 `member1`은 이미 영속성 컨텍스트에 있으므로 버리고 기존에 있던 `member1`이 반환 대상이 된다.
5. 식별자 값을 기준으로 `member2`는 영속성 컨텍스트에 없으므로 영속성 컨텍스트에 추가한다.
6. 쿼리 결과인 `member1`, `member2`를 반환한다. 여기서 `member1`은 쿼리 결과가 아닌 영속성 컨텍스트에 있던 엔티티다.

- JPQL로 조회한 엔티티는 영속 상태다.
- 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.

그런데 `왜 데이터베이스에서 새로 조회한 member1 을 버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환하는 것일까?` JPQL로 조회한 새로운 엔티티를 영속성 컨텍스트에 하나 더 추가하거나 기존 엔티티를 새로 검색한 엔티티로 대체하면 어떤 문제가 있는 것일까? 그 이유는 영속성 컨텍스트는 엔티티의 동일성을 보장한다. 따라서 `기존 엔티티는 그대로 두고 새로 검색한 엔티티를 버린다.` 다시 말하면, `영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장한다.` `em.find()` 로 조회하든 JPQL을 사용하든 영속성 컨텍스트가 같으면 동일한 엔티티를 반환한다.

## find() vs JPQL
`em.find()` 메서드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다. 따라서 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다. (그래서 1차 캐시라 부른다.)
```java
//최초 조회, 데이터베이스에서 조회 
Member member1 = em.find(Member.class, 1L); 
//두 번째 조회, 영속성 컨텍스트에 있으므로 데이터베이스를 조회하지 않음 
Member member2 = em.find(Member.class, 1L); 
//member1 == member2는 주소 값이 같은 인스턴스
```

그렇다면 JPQL은 어떤 방식으로 동작할까?
```java
//첫 번째 호출 : 데이터베이스에서 조회 
Member member1 = em.createQuery("select m from Member m where m.id = :id", Member.
 .setParameter("id", 1L) 
 .getSingleResult();
//두 번째 호출 : 데이터베이스에서 조회 
Member member2 = em.createQuery("select m from Member m where m.id = :id", Member.
 .setParameter("id", 1L) 
 .getSingleResult();
 
//member1 == member2는 주소값이 같은 인스턴스
```
`em.find()` 를 2번 사용한 로직과 마찬가지로 주소 값이 같은 인스턴스를 반환하고 결과도 같다. 하지만 내부 동작방식은 조금 다르다.

#### JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회한다.
`em.find()` 메서드는 영속성 컨텍스트에서 엔티티를 먼저 찾고 없으면 데이터베이스를 조회하지만 JPQL을 사용하면 데이터베이스를 먼저 조회한다. (JPA 구현체 개발자 입장에서 `em.find()` 메서드는 파라미터로 식별자 값을 넘기기 때문에 영속성 컨텍스트를 조회하기 쉽지만, JPQL을 분석해서 영속성 컨텍스트를 조회하는 것은 쉬운일이 이니다. 따라서 JPQL로 쿼리한 결과 값을 사용한다.)      

이 코드에서 첫 번째 JPQL을 호출하면 데이터베이스에서 회원 엔티티( `id=1L` )를 조회하고 영속성 컨텍스트에 등록한다. 두 번째 JPQL을 호출하면 데이터베이스에서 같은 회원 엔티티( `id=1L` )를 조회한다. 이때 영속성 컨텍스트에 이미 조회한 같은 엔티티가 있다. 앞서 이야기 한데로 새로 검색한 엔티티는버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환한다.

#### JPQL의 특징 정리
- JPQL은 항상 데이터베이스를 조회한다.
- JPQL로 조회한 엔티티는 영속 상태다.
- 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.
